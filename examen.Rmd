---
title: "examen"
author: "Edgar Granados"
date: "September 30, 2018"
output: html_document
---

```{r setup, include=FALSE}
library(datasets)
library(tidyverse)
library(ggplot2)
data(iris)
summary(iris)
```

## 1. Manipulaci√≥n y Visualizaci√≥n de Datos en R
a. Cumple la base de datos (iris) con el principio de datos limpios?
Res. Considerando que la unididad observacional es una flor, s√≠ cumple con el principio de datos limpios ya que cada variable forma una columna (principio 1). El principio 2 se cumple al tener solamente una tabla para la unidad observacional "flor". El principio 3 se cumple ya que cada valor de la unidad observacional "flor" es en efecto un rengl√≥n. 


b. En caso de que no cumpla con el principio de datos limpios, limpe los datos. Imprima las primeras 6 l√≠neas de los datos limpios. (si ya estaban limpios, entonces imprima las primeras 6 l√≠neas de los datos originales)
Res. 
```{r pr_1b}
head(iris)
```

c. Cu√°ntas observaciones y cu√°ntas variables tiene la base de datos?
Res. Utilizando la funci√≥n "summary" es posible responder √©sta pregunta facilmente. La base de datos contiene 5 variables. Se tienen 150 observaciones (50 de cada una de las tres especies de flor).
```{r pr_c}
summary(iris)
```

d. Cu√°l es la clase at√≥mica de cada una de las variables?
Res. Para obtener la clase at√≥mica de cada variable, se utiliza la funci√≥n "class". En el caso de la variable "Species", se utiliza la funci√≥n "typeof" a la salida de "class" debido a que se trata de una estructura "factor". Con esto se obtiene que, todas las variables son de tipo "numeric" excepto por la variable "Species" que es de tipo "character".
```{r warning=FALSE}
class(iris$Species)
typeof(class(iris$Species))
class(iris$Sepal.Length)
class(iris$Sepal.Width)
class(iris$Petal.Length)
class(iris$Petal.Width)
```

e. Filtre las flores de la especia Setosa e imprima las primeras 6 observaciones
Res. Se utiliza la funci√≥n "filter" para obtener todas las ocurrencias de "setosa" y √©sta salida se pasa a la funci√≥n "head".
```{r pr_e}
head(filter(iris, Species == "setosa"))
```

f. Ordene la base de datos de manera descendente con respecto a la variable Petal.Length e imprima las primeras 6 observaciones.
Res. Para ordenar una base de datos, se utiliza la funci√≥n "arrange" definiendo las variables que se desea ordenera. En particular, a la variable "Petal.Length" se le aplica la funci√≥n "desc" para que se ordene de manera descendiente. A la salida, se aplica la funci√≥n "head" para obtener las primeras 6 observaciones.
```{r pr_f}
head(arrange(iris, desc(Petal.Length)))
```

g. Cree una nueva variable en donde se muestre el atributo Sepal.Length en mil√≠metros e imprima las 6 primeras observaciones.
Res. Se utiliza la funci√≥n "mutate" para agregar una nueva variable (columna). Para los valores de √©sta nueva columna, se toman los valores de la columna "Sepal.Length" y se multiplican por 10.
```{r pr_g}
head(mutate(iris, Sepal.Length.cm = iris$Sepal.Length* 10))
```

h. Elimine las observaciones con valores faltantes en la variable Sepal.Width e indique el n√∫mero de observaciones de la nueva base de datos.

Res. Examninando la base de datos original, no se encontraron valores faltantes para ninguna variable. 
```{r pr_h}

```

i. Cu√°l es la media de la variable Petal.Width para cada una de las especies de flores?
Res. Las medias son las siguientes:
setosa - 0.2
versicolor - 1.3
virginica - 2.0
Se utiliza la funci√≥n "filter" para filtrar los datos requeridos y la funci√≥n summary para obtener la media. A continuaci√≥n se muestran los comandos para obtener las medias:
```{r pr_i}
summary(filter(iris, Species == "setosa"))
summary(filter(iris, Species == "versicolor"))
summary(filter(iris, Species == "virginica"))
```

j.Realice una gr√°fica de dispersi√≥n de las variables x=Sepal.Length contra y=Sepal.Width en la que se distingan las diferentes esoecies por color o por forma de los puntos. La gr√°fica debe incluir t√≠tulo y nombres de los ejes horizontal y vertical.
```{r pr_j}
ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species)) + geom_point() + ggtitle("Length vs Width of Flowers Sepals by Species") + xlab("Length") + ylab("Width")
```

k. Realice una gr√°fica de cajas de la variable Petal.Length en la que se distingan las diferentes especies
```{r pr_k}
ggplot(iris, aes(Species, Petal.Length)) + geom_boxplot() + ggtitle("Petal Length by Specie") + xlab("Specie") + ylab("Length")
```

# 2. Espacio de Probabilidad y Variables Aleatorias
```{r pr_}

```

```{r pr_}

```

# 4.  Bootstrap
Se desea simular muestras de tama√±o 20 de una distribuci√≥n exponencial con tasa ùúÜ  =1/ùõΩ= 1.
El estad√≠stico de inter√©s ùúÉÃÇ es el estimador de la media ùúÉ = ùõΩ. Siga el siguiente procedimiento:
  i. Utilice la funci√≥n rexp() (y la semilla 261285) para generar una muestra
aleatoria de tama√±o 20 de una distribuci√≥n exponencial con ùõΩ = 1.
  ii. Genere 2,000 muestras bootstrap y calcule intervalos de confianza con coeficiente
de confianza de 95% para ùúÉÃÇ usando 1) el m√©todo normal, 2) percentiles y 3) ùêµùê∂ùëé.
  iii. Revise si el intervalo de confianza contiene el verdadero valor del par√°metro ùúÉ; en
caso de que no lo contenga registre si fall√≥ por la izquierda o fall√≥ por la derecha.
a. Repita 500 veces el procedimiento descrito y llena la siguiente tabla (utilice una sola vez la
semilla)
Res. El procedimiento descrito se realiza en una funci√≥n llamada "proc_examen". EL procedimiento se repite 500 veces usando la funci√≥n rerun y se guarda el resultado en un arreglo. Se implement√≥ una funci√≥n para pasar de dicho arreglo a un "data frame" para poder filtrar los resultados de acuerdo a si el par√°metro se encuentra o no en el intervalo (usando la funci√≥n "filter"). Por √∫ltimo se obtienen los resultados como porcentaje y se imprimen.
```{r pr_4a}
proc_examen <- function()
{

	mediaBoot <- function(x)
	{ 
		muestra_boot <- sample(x, size = length(x), replace = TRUE) 
		mean(muestra_boot) # Replicacion bootstrap de theta_gorro
	}
	se <- function(x) sum((x - mean(x)) ^ 2) / length(x)
	skewness <- function(x)
	{
    	n <- length(x)
    	1 / n * sum((x - mean(x)) ^ 3) / sd(x) ^ 3 
	}
	skewness_boot <- function(x_boot)
	{
		x_boot <- sample(x, length(x), replace = TRUE)
		skewness(x_boot)
	}
	muestra <- rexp(20, 1/beta)
	thetas_boot <- rerun(2000, mediaBoot(muestra)) %>% flatten_dbl()
	theta_hat <-skewness(muestra)
	
	li_normal <- round(theta_hat - 1.96 * sd(thetas_boot), 2)
	ls_normal <- round(theta_hat + 1.96 * sd(thetas_boot), 2)

	ls_per <- round(quantile(thetas_boot, prob = 0.975), 2)
	li_per <- round(quantile(thetas_boot, prob = 0.025), 2)

	b_var <- rerun(2000, 
				se(sample(muestra, size = length(muestra), 
					replace = TRUE))) %>% flatten_dbl()
	ls_bc <- round(quantile(b_var, prob = 0.95), 2)
	li_bc <- round(quantile(b_var, prob = 0.05), 2)

	return(c(li_normal, ls_normal, li_per, ls_per, li_bc, ls_bc))
}
get_df_from_res <- function(arr)
{	
	df <- tribble(
  		~prueba, ~li_normal, ~ls_normal, ~li_per, ~ls_per, ~li_bc, ~ls_bc
	)
	cont <- 1
	for (i in 1:length(arr))
	{
	  switch(((i-1) %% 6)+1,
	  	li_normal <- arr[i],
	  	ls_normal <- arr[i],
	  	li_per <- arr[i],
	  	ls_per <- arr[i],
	  	{
	  		li_bc <- arr[i]
	  	},
	  	{
	  		ls_bc <- arr[i]
	  		df <- add_row(df, prueba = cont, 
	  					li_normal = li_normal,
	  					ls_normal = ls_normal,
	  					li_per = li_per,
	  					ls_per = ls_per,
	  					li_bc = li_bc,
	  					ls_bc = ls_bc
	  			)
	  		cont <- cont + 1
	  	}
	  	)

	}
	return(df)
}
set.seed(261285)
res_aux <- rerun(500, proc_examen()) %>% flatten_dbl()
df_res_aux <- get_df_from_res(res_aux)

norm_izq <- nrow(filter(df_res_aux, li_normal > 1))
norm_der <- nrow(filter(df_res_aux, ls_normal < 1))
per_izq <- nrow(filter(df_res_aux, li_per > 1))
per_der <- nrow(filter(df_res_aux, ls_per < 1))
bc_izq <- nrow(filter(df_res_aux, li_bc > 1))
bc_der <- nrow(filter(df_res_aux, ls_bc < 1))

norm_cob <- nrow(filter(df_res_aux, li_normal <= 1, 1 <= ls_normal))
per_cob <- nrow(filter(df_res_aux, li_per <= 1, 1 <= ls_per))
bc_cob <- nrow(filter(df_res_aux, li_bc <= 1, 1 <= ls_bc))

cat("Normal:\t")
cat(norm_izq/500, ", ", norm_der/500, ", ", norm_cob/500)
cat("\nPer:\t")
cat(per_izq/500, ", ", per_der/500, ", ", per_cob/500)
cat("\nBC:\t")
cat(bc_izq/500, ", ", bc_der/500, ", ", bc_cob/500)
cat("\n")

```

b. Realice una gr√°fica de paneles: en cada panel mostrar√° los resultados de uno de los
m√©todos (normal, percentil y ùêµùê∂ùëé), en el eje horizontal graficar√° el n√∫mero de intervalos
de confianza (1,2,‚Ä¶,500) y en el eje vertical graficar√° los l√≠mites de los intervalos, es decir,
graficar√° 2 l√≠neas (use la funci√≥n geom_line): una corresponder√° a los l√≠mites inferiores
de los intervalos y la otra a los superiores.

Res. Se realiza una gr√°fica para cada uno de los m√©todos y despu√©s se realiza una sola gr√°fica (multiplot) utilizando un script del libro "Cookbook for R".
```{r pr_}
p_norm <- ggplot() + 
	geom_line(data = df_res_aux, aes(x = prueba, y = li_normal, color = "blue")) +
	geom_line(data = df_res_aux, aes(x = prueba, y = ls_normal, color = "red")) + 
	xlab("") + ylab("Beta") + scale_color_discrete(name = "Intervalos", labels = c("li", "ls")) + 
	ggtitle("Variaci√≥n de los Intervalos Para Cada M√©todo") + theme(plot.title = element_text(hjust = 0.5))
p_per <- ggplot() + 
	geom_line(data = df_res_aux, aes(x = prueba, y = li_per, color = "blue")) +
	geom_line(data = df_res_aux, aes(x = prueba, y = ls_per, color = "red")) + 
	xlab("") + ylab("Beta") + scale_color_discrete(name = "Intervalos", labels = c("li", "ls"))

p_bc <- ggplot() + 
	geom_line(data = df_res_aux, aes(x = prueba, y = li_bc, color = "blue")) +
	geom_line(data = df_res_aux, aes(x = prueba, y = ls_bc, color = "red")) + 
	xlab("Intervalo") + ylab("Beta") + scale_color_discrete(name = "Intervalos", labels = c("li", "ls"))
multiplot(p_norm, p_per, p_bc, cols = 1)

```

5. Simulaci√≥n de Variables Aleatorias
Una variable aleatoria X tiene una distribuci√≥n binomial con par√°metros n y p, esto es, X~Binomial(n, p), si su funci√≥n de masa de probabilidad es (...).
El objetivo es generar X a partir de una variable aleatoria U con distribuci√≥n uniforme continua en el itervalo (0,1) utilizando el m√©todo de Transformaci√≥n Inversa Discreta. La clave para utilizar este m√©todo en el presente caso es seguir el procedimiento indicado.Ì±ã 
a. Encuentre la relaci√≥n de recurrencia entre p_i+1 y p_i para i > 0.

```{r pr_}

```


b. Utilizando la relaci√≥n de recurrencia del inciso anterior, escribir un algoritmo de 5 pasos que genere una variable aleatoria binomial con par√°metros n y p mediante el m√©todo de Transformaci√≥n Inversa Discreta.
```{r pr_5b}

```

c. Escriba en R una funci√≥n que implemente el algoritmo del inciso b para n = 10 y p = 0.3
```{r pr_5c}
rBinomialI <- function(n, p)
  {
  U <- runif(1)
  i <- 0
  p_i <- (1 - p) ^ n
  P <- p_i
  while(U >= P){
    i <- i + 1
    p_i <- (p_i / (1 - p) ) * (n - i + 1) * p / i 
    P <- P + p_i
  }
  i
}
rBinomialI(10, 0.3)
```

d. Realice 10,000 simulaciones utilizando la semilla 221285 y reporte las primeras 5 simulaciones obtenidas
```{r pr_5d}
set.seed(221285)
binomial_aux <- rerun(10000, rBinomialI(10, 0.3)) %>% flatten_dbl()
binomial_aux[1:5]
```

e. Genere un histograma con las 10,000 simulaciones anteriores y comp√°relo con una distribuci√≥n construida utilizando la funci√≥n dbinom de R.
```{r pr_5e}
set.seed(221285)
binomial_aux <- rerun(10000, rBinomialI(10, 0.3)) %>% flatten_dbl()
df_binomial_aux <- as.data.frame(0:10)

df_binomial_aux <- add_column(df_binomial_aux, 0)
df_res <- as_data_frame(table(binomial_aux))
for (i in 1:length(df_res$n))
{
	df_binomial_aux[i,2] <- df_res$n[i]
}
rbinom_v <- rbinom(10000, 10, 0.3)
df_binomial_aux <- mutate(df_binomial_aux, rbin = table(rbinom_v))
names(df_binomial_aux) <- c("i", "MTID", "rbin")
df_tot_bin <- mutate(df_tot_bin, rbin = rbinom_v, i = 1:10000)
ggplot() + 
	geom_point(data = df_tot_bin, 
		aes(x = i, y = binomial_aux, color = "red")) + 
	geom_point(data = df_tot_bin, 
		aes(x = i, y = rbin, color = "blue")) +
	xlab("Iteraci√≥n") + ylab("Valor") + 
	scale_color_discrete(name = "M√©todo", labels = c("MTID", "rbinom"))

ggplot() + 
	geom_point(data = df_binomial_aux, 
		aes(x = i, y = MTID, color = "red")) + 
	geom_point(data = df_binomial_aux, 
		aes(x = i, y = rbin, color = "blue")) +
	xlab("Iteraci√≥n") + ylab("Valor") + 
	scale_color_discrete(name = "M√©todo", labels = c("MTID", "rbinom"))

```

















